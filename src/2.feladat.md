# C# Tananyag – Dobókocka szimuláció és Enum típus használata

Ebben a tananyagban egy dobókocka szimulációt készítünk.  
A feladatunk az lesz, hogy **100-szor dobjunk egy dobókockával**, számoljuk meg, hogy az egyes értékek hányszor fordulnak elő, és minden egyes dobásnál írjuk ki, hogy **páros vagy páratlan** szám jött ki.  

Ezen felül bemutatjuk a **`enum` típus** használatát, amivel beszédes neveket adhatunk a dobás eredményeinek (például `Dobas.Hármas` ahelyett, hogy csak a `3` számmal hivatkoznánk).  

---

## 1. fejezet – Mi az az `enum` és miért jó?

### Magyarázat
Az `enum` (felsorolt típus) egy olyan adatszerkezet, amely lehetővé teszi, hogy **számokhoz neveket rendeljünk**.  
Ez nagyon hasznos, mert a kódban sokkal olvashatóbb lesz az, ha a dobás eredményét `Dobas.Hármas` néven említjük, mint ha csak a `3` számot használnánk.  

Így nem kell fejben tartanod, hogy a `3` az a "Hármas dobás", hanem a program szövege magától érthető lesz.

> **C++ párhuzam:**  
> C++-ban ugyanígy van `enum` típus. A működés szinte teljesen azonos.  
> Egyetlen különbség, hogy C#-ban gyakrabban használnak `enum`-ot együtt `switch` szerkezettel, és gyakran konvertálnak oda-vissza int és enum között.

### Kód
```csharp
using System;

namespace fa2
{
    internal class Program
    {
        // enum felsorolás a dobás értékeire
        enum Dobas { Egyes = 1, Kettes, Hármas, Négyes, Ötös, Hatos }

        static void Main(string[] args)
        {
            // itt fogjuk majd megírni a dobókocka programot

            Console.ReadLine(); // várakozás, hogy ne záródjon be a program
        }
    }
}
```

---

## 2. fejezet – 100 dobás előkészítése

### Magyarázat
A programunknak 100-szor kell dobnia egy dobókockával.  
Ehhez létrehozunk két tömböt:  
- **`dobasok[100]`** – ebben tároljuk majd a dobott értékeket (hogy később akár visszanézhessük őket).  
- **`gyakorisag[6]`** – ebben számoljuk, hogy az egyes oldalak hányszor fordultak elő.  

Egy `Random` osztályt fogunk használni, amivel véletlen számot generálunk.  
A `rnd.Next(1, 7)` metódus mindig **1 és 6 közötti** egész számot ad vissza – pont úgy, ahogy egy dobókocka működik.

> **C++ párhuzam:**  
> C++-ban nincs beépített `Random` osztály, hanem `<random>` könyvtárat kell használni.  
> Példa:  
> ```cpp
> std::random_device rd;
> std::mt19937 gen(rd());
> std::uniform_int_distribution<> dis(1, 6);
> int dobas = dis(gen);
> ```

### Kód
```csharp
using System;

namespace fa2
{
    internal class Program
    {
        enum Dobas { Egyes = 1, Kettes, Hármas, Négyes, Ötös, Hatos }

        static void Main(string[] args)
        {
            // innentől új kód

            int[] dobasok = new int[100]; // 100 dobás tárolására
            int[] gyakorisag = new int[6]; // 6 oldal előfordulásainak számlálására

            Random rnd = new Random(); // véletlenszám generátor

            Console.ReadLine();
        }
    }
}
```

---

## 3. fejezet – Dobások szimulálása

### Magyarázat
Most megírjuk a ciklust, ami **100-szor lefut**.  
Minden egyes lépésben:  
1. Generálunk egy számot 1 és 6 között.  
2. Ezt eltároljuk a `dobasok` tömbben.  
3. A `gyakorisag` tömb megfelelő elemét növeljük eggyel.  
   - Például ha `4` jött ki, akkor a `gyakorisag[3]++` történik.  

Ezáltal a ciklus végére lesz egy listánk az összes dobásról, és egy számlálónk, hogy az egyes oldalak hányszor jöttek ki.

> **C++ párhuzam:**  
> A ciklus és a tömbkezelés szinte teljesen ugyanaz.  
> `for (int i = 0; i < 100; i++) { ... }` ugyanígy működik C++-ban is.

### Kód
```csharp
using System;

namespace fa2
{
    internal class Program
    {
        enum Dobas { Egyes = 1, Kettes, Hármas, Négyes, Ötös, Hatos }

        static void Main(string[] args)
        {
            int[] dobasok = new int[100];
            int[] gyakorisag = new int[6];
            Random rnd = new Random();

            // innentől új kód

            for (int i = 0; i < dobasok.Length; i++) // 100-szor lefut
            {
                dobasok[i] = rnd.Next(1, 7); // 1 és 6 közötti dobás
                gyakorisag[dobasok[i] - 1]++; // megfelelő gyakoriság növelése
            }

            Console.ReadLine();
        }
    }
}
```

---

## 4. fejezet – Páros vagy páratlan eldöntése

### Magyarázat
Most minden dobás után kiírjuk a számot, és mellé azt, hogy **páros vagy páratlan**.  
Ehhez konvertáljuk a számot `Dobas` típussá:  
```csharp
Dobas d = (Dobas)dobasok[i];
```

Ez azt jelenti, hogy a `3` helyett `Dobas.Hármas` néven tudunk rá hivatkozni.

Ezután egy `switch`-el eldöntjük, hogy páros vagy páratlan dobásról van szó, és kiírjuk a képernyőre.

> Miért fontos ez?
> A páros/páratlan eldöntés gyakori programozási feladat. Ezzel gyakoroljuk a vezérlési szerkezeteket és az `enum` használatát is.

> C++ párhuzam:
> C++-ban az `enum` és a `switch` teljesen hasonló.
> A különbség inkább a `Console.WriteLine` helyett a `std::cout` használata lenne.

### Kód

```csharp
using System;

namespace fa2
{
    internal class Program
    {
    enum Dobas { Egyes = 1, Kettes, Hármas, Négyes, Ötös, Hatos }
        static void Main(string[] args)
        {
            int[] dobasok = new int[100];
            int[] gyakorisag = new int[6];
            Random rnd = new Random();
    
            for (int i = 0; i < dobasok.Length; i++)
            {
                dobasok[i] = rnd.Next(1, 7);
                gyakorisag[dobasok[i] - 1]++;
    
                // innentől új kód
    
                Console.Write(dobasok[i]); // kiírjuk a dobott számot
                Dobas d = (Dobas)dobasok[i]; // enum típusra alakítjuk
                switch (d)
                {
                    case Dobas.Egyes:
                    case Dobas.Hármas:
                    case Dobas.Ötös:
                        Console.WriteLine(" - páratlan");
                        break;
    
                    case Dobas.Kettes:
                    case Dobas.Négyes:
                    case Dobas.Hatos:
                        Console.WriteLine(" - páros");
                        break;
                }
            }
    
            Console.ReadLine();
        }
    }
}
```

---

## 5. fejezet – Gyakoriságok kiírása
### Magyarázat

Végül kiírjuk, hogy az **egyes számokból hányszor dobtunk.**
Ehhez a `gyakorisag` tömböt végigjárjuk, és minden elemhez kiírjuk a megfelelő `enum` nevet is.

Így a kimenet például lehet:
```
Egyes gyakorisága: 18
Kettes gyakorisága: 16
...
```

> **C++ párhuzam:**
> C++-ban ugyanígy kellene egy `for` ciklussal végigmenni a számlálótömbön, és `std::cout`-tal kiírni az eredményeket.
> 
### Kód

```csharp
using System;

namespace fa2
{
    internal class Program
    {
    enum Dobas { Egyes = 1, Kettes, Hármas, Négyes, Ötös, Hatos }
    
        static void Main(string[] args)
        {
            int[] dobasok = new int[100];
            int[] gyakorisag = new int[6];
            Random rnd = new Random();
    
            for (int i = 0; i < dobasok.Length; i++)
            {
                dobasok[i] = rnd.Next(1, 7);
                gyakorisag[dobasok[i] - 1]++;
    
                Console.Write(dobasok[i]);
                Dobas d = (Dobas)dobasok[i];
                switch (d)
                {
                    case Dobas.Egyes:
                    case Dobas.Hármas:
                    case Dobas.Ötös:
                        Console.WriteLine(" - páratlan");
                        break;
    
                    case Dobas.Kettes:
                    case Dobas.Négyes:
                    case Dobas.Hatos:
                        Console.WriteLine(" - páros");
                        break;
                }
            }
    
            // innentől új kód
    
            Console.WriteLine("gyakoriságok:");
            for (int i = 0; i < gyakorisag.Length; i++)
            {
                Console.WriteLine($"{(Dobas)(i + 1)} gyakorisága: {gyakorisag[i]}");
            }
    
            Console.ReadLine();
        }
    }
}
```

## Összegzés

Ebben a programban megtanultuk:
- hogyan hozzunk létre enum típust és hogyan használjuk switch szerkezettel,
- hogyan szimuláljunk 100 dobást véletlenszám-generátorral,
- hogyan számoljuk meg a gyakoriságokat tömb segítségével,
- hogyan döntsük el, hogy egy szám páros vagy páratlan.

Ezek mind alapvető, de nagyon fontos programozási fogások, amelyek a későbbi bonyolultabb feladatoknál is előkerülnek.
