# Tananyag: Struktúrák használata C#-ban – `Film` példa

## 1. Bevezetés

A **struktúra** (`struct`) C#-ban hasonlít az **osztályhoz** (`class`), de néhány fontos különbséggel:
- érték típus (nem referencia típus, mint az osztály),
- általában **egyszerűbb adatszerkezetek** tárolására használjuk,
- példányai **nem kerülnek a heap-re**, hanem a stacken tárolódnak (ez teljesítmény szempontjából számít),
- **nem örökölhetnek** más struktúrát, de interfészeket megvalósíthatnak.

Ebben a feladatban egy `Film` struktúrát hozunk létre, amely egy film adatait tárolja.

---

## 2. `Film` struktúra kódja

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace fa1_struktura
{
    internal struct Film
    {
        private string rendezo, cim;         // rendező és cím mezők
        private uint gyartas_eve;            // gyártási év, pozitív egész (uint)

        // Konstruktor 1 – csak rendező megadásával
        public Film(string r)
        {
            rendezo = r;         // a rendező nevét beállítjuk
            cim = "valami";      // alapértelmezett cím
            gyartas_eve = 1999;  // alapértelmezett év
        }

        // Konstruktor 2 – minden adatot megadunk
        public Film(string rendezo, string cim, uint gyartas_eve) : this(rendezo)
        {
            this.cim = cim;                 // a paraméterként kapott cím
            this.gyartas_eve = gyartas_eve; // és gyártási év beállítása
        }
    }
}
```

### Magyarázat

- A `private` kulcsszó azt jelenti, hogy ezek a mezők **csak a struktúrán belül** érhetők el.  
- Két **konstruktor** van:
  - Az első csak a rendezőt várja, és ad neki alapértelmezett cím/évet.
  - A második az első konstruktort hívja meg (`: this(rendezo)`), így újrahasznosítja annak kódját, majd kiegészíti további adatokkal.

> **C++ párhuzam:**  
> - C++-ban a `struct` és `class` szinte azonos, csak az alapértelmezett láthatóság különbözik (`public` vs `private`).  
> - Itt a C# `struct` inkább egy könnyített osztály, amely **értékként viselkedik** – C++-ban ez a viselkedés a másolás során természetes.

---

## 3. Program (Main metódus)

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace fa1_struktura
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Film film = new Film();                      // alapértelmezett példány (mezők alapértékekkel)
            Film film2 = new Film("rendező","cím",1999); // teljes konstruktor használata
        }
    }
}
```

### Magyarázat

- A `Film film = new Film();` sor létrehoz egy **üres struktúra példányt**, ahol minden mező az alapértékével indul (string → `null`, szám → `0`).  
- A `Film film2 = new Film("rendező", "cím", 1999);` viszont a **második konstruktort** hívja meg, így a `rendezo`, `cim` és `gyartas_eve` értékei rögtön beállnak.

> **Megjegyzés:**  
> Struktúrákban a **paraméter nélküli konstruktor** implicit módon létezik, és nem írható felül – ez eltér a C++-tól, ahol teljes szabadság van a konstruktorok definiálásában.

---

## 4. Összefoglalás

A struktúrák:
- kis, önálló adategységek tárolására alkalmasak,
- értékként másolódnak (nem referenciaként),
- konstruktorokkal inicializálhatók, de korlátozottabban, mint osztályok.

Használd őket, ha egy objektum:
- nem igényel öröklést,
- kicsi és egyszerű adatot reprezentál (pl. film, pont, dátum, szín stb.).

---
