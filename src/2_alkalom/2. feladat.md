# Tananyag – Pont és Egyenes osztály C#-ban

## 1. Bevezetés

Ebben a feladatban **geometriai objektumokat** modellezünk C#-ban:
- egy **Pont** osztályt, amely egy (x, y) koordinátát tárol,
- egy **Egyenes** osztályt, amely két Pontból áll, és képes meghatározni:
  - az egyenes **meredekségét**,
  - valamint az **x-tengellyel bezárt szögét**.

Ezzel a példával megismerkedünk:
- az **osztályok közötti kapcsolat** (egyik osztály tartalmazza a másikat),
- a **tulajdonságok (property)** használatával,
- és a **matematikai függvényekkel** (`Math` osztály a .NET-ben).

> **C++ párhuzam:**  
> - C++-ban ez hasonló lenne egy `struct` vagy `class` megoldáshoz, ahol példányokat (objektumokat) adunk át konstruktoroknak és metódusoknak.  
> - C#-ban az `object` alapú szemlélet még szorosabb: mindent osztályokon keresztül kezelünk.

---

## 2. `Pont` osztály

```csharp
using System;

namespace fa2
{
    internal class Pont
    {
        private double x, y; // mezők (adatok) az x és y koordinátához

        // Konstruktor: két koordináta megadása
        public Pont(double x, double y)
        {
            this.x = x;
            this.y = y;
        }

        // Tulajdonságok (property-k): így szabályozottan érhetjük el a mezőket
        public double X { get { return x; } set { x = value; } } // getter és setter
        public double Y { get { return y; } }                    // csak getter

        // Szöveges megjelenítés (ToString): így tudjuk szépen kiírni az objektumot
        public override string ToString()
        {
            return $"({x}; {y})";
        }
    }
}
```

### Magyarázat

- A `private` kulcsszóval elzárjuk az adattagokat (jó gyakorlat az objektumorientált tervezésben).  
- A `public double X` és `Y` **property-k** biztosítják a szabályozott hozzáférést.  
  - `get` — lekérdezés,  
  - `set` — módosítás (itt csak `X`-hez engedett).  
- A `ToString()` metódus segítségével az objektum **emberi olvasható formában** jelenik meg.  
  - Példa: ha `x=2` és `y=3`, akkor `ToString()` → `(2; 3)`  

> **C++ párhuzam:**  
> - A getter/setter metódusoknak itt van rövidebb szintaxisa (`get` / `set` kulcsszavak).  
> - C++-ban ugyanezt külön függvényekkel oldanánk meg (`getX()`, `setX()` stb.).  

---

## 3. `Egyenes` osztály

```csharp
using System;

namespace fa2
{
    internal class Egyenes
    {
        private Pont p1, p2; // két pont, amely meghatározza az egyenest
        private double szog; // az x-tengellyel bezárt szög (fokban)

        public double Szog { get { return szog; } } // lekérdező tulajdonság

        // Konstruktor: két pont alapján hozzuk létre az egyenest
        public Egyenes(Pont p1, Pont p2)
        {
            // Deep copy: új példányokat hozunk létre, hogy az eredeti pontokat ne lehessen módosítani
            this.p1 = new Pont(p1.X, p1.Y);
            this.p2 = new Pont(p2.X, p2.Y);
        }

        // Metódus a meredekség és a szög meghatározására
        public double Meredekseg()
        {
            double m = (p2.Y - p1.Y) / (p2.X - p1.X); // meredekség képlete
            szog = Math.Atan(m) * (180 / Math.PI);    // radián → fok átváltás
            return m;                                 // visszaadjuk a meredekséget
        }

        // Szöveges megjelenítés
        public override string ToString()
        {
            return string.Format($"e: {p1} - {p2}");
        }
    }
}
```

### Magyarázat

1. **Meredekség számítása**  
   Matematikai képlet:
```m = (y2 - y1) / (x2 - x1)```
Ez adja meg, hogy az egyenes **mennyire emelkedik** az x-tengelyhez képest.

2. **Szög meghatározása**  
A meredekség és a szög között:
```tan(α) = m```

Ezért:
```α = arctan(m)```
A `Math.Atan(m)` függvény **radiánban** adja meg az eredményt, ezért átváltjuk fokokra:
```fok = radián * (180 / π)```

3. **Deep copy magyarázat**  
Az új `Pont` példányokat azért hozzuk létre (`new Pont(...)`), hogy az eredeti pontok módosítása ne befolyásolja az egyenest.  
Ez az ún. **mély másolat (deep copy)**.

> **C++ párhuzam:**  
> - A `Math` osztály helyett C++-ban a `cmath` függvényeit (`atan`, `M_PI`) használnánk.  
> - Az objektumok másolása ugyanúgy lehetséges copy constructorral.

---

## 4. `Program` (Main metódus)

```csharp
using System;

namespace fa2
{
 internal class Program
 {
     static void Main(string[] args)
     {
         Pont A = new Pont(2, 3);   // első pont
         Pont B = new Pont(4, 5);   // második pont

         Console.WriteLine(A.X);    // kiírja az X koordinátát
         A.X = 10;                  // módosítja az X értéket (set)
         Console.WriteLine(A.X);    // új érték kiíratása

         Egyenes e = new Egyenes(A, B); // egyenes létrehozása két pontból

         Console.WriteLine(e);             // ToString() meghívódik automatikusan
         Console.WriteLine(e.Szog);        // kiírja a szöget (fokban)
         Console.WriteLine("meredekség: " + e.Meredekseg());
         Console.WriteLine("Az x tengellyel bezárt szög: " + e.Szog);
         Console.WriteLine("egyenes: " + e);
         Console.WriteLine("pont: " + A);

         Console.ReadLine(); // várakozás
     }
 }
}
```

### Magyarázat

- Két `Pont` létrehozása, majd egy `Egyenes` objektum a kettőből.  
- Az `Egyenes.Meredekseg()` meghívásával a program kiszámítja:
- a meredekséget,
- és a szöget (ami elérhető a `Szog` property-n keresztül).  
- A `Console.WriteLine(e)` automatikusan meghívja az `Egyenes` osztály `ToString()` metódusát, tehát szépen formázva jelenik meg az egyenes.

> **Fontos tanulság:**  
> - A tulajdonságok (`get` / `set`) biztonságos adatkezelést tesznek lehetővé.  
> - A konstruktorok felelősek az adatok helyes beállításáért.  
> - A `Math` osztály függvényei (pl. `Atan`, `PI`) minden komoly számításhoz elérhetők a .NET-ben.

---

## 5. Összefoglalás

Ez a feladat megtanítja:
- hogyan reprezentáljunk **geometriai objektumokat** osztályokkal,
- hogyan kapcsolódhatnak egymáshoz az osztályok (kompozíció),
- hogyan számoljunk matematikai tulajdonságokat (meredekség, szög),
- és hogyan használjuk a **property**, **ToString**, **Math** és **konstruktor** fogalmakat együtt.

> **C++-ban** mindez hasonlóan működne, csak a szintaxis más: osztályok, metódusok, függvények és getterek/setterek ugyanilyen logikai szerepet töltenének be.

---
