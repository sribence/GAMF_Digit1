# C# Tananyag – Tökéletes számok kiírása 1-től N-ig

Ebben a programban megtanuljuk, hogyan lehet kiszámolni a **tökéletes számokat**.  
Egy szám tökéletes, ha **az osztóinak összege (a számnál kisebb osztók)** megegyezik magával a számmal.  
Példa: 6 → osztói: 1, 2, 3 → összege: 1+2+3=6 → tökéletes szám.

---

## 1. fejezet – Alapok és fő programstruktúra

### Magyarázat
Minden C# program **`namespace`**, **`class`**, **`Main`** metódussal kezdődik:  
- `namespace fa3_TokeletesSzam` — a program neve, logikailag elkülöníti a kódot.  
- `class Program` — a program osztálya, minden metódus itt található.  
- `static void Main(string[] args)` — a program belépési pontja, innen indul a végrehajtás.  

> **C++ párhuzam:**  
> - C++-ban nincs `namespace` kötelezően, bár lehet használni.  
> - A `main()` függvény hasonló a `Main()` metódushoz.  
> - A statikus metódusok (C#) C++-ban a `static` függvényekhez hasonlóak.

---

## 2. fejezet – Osztók keresése

### Magyarázat
Ahhoz, hogy egy szám tökéletes-e, először **meg kell találnunk az osztóit**.  
A függvényünk: `OsztokKeresese(int[] osztok, int N)`

1. **Miért tömb?**  
   - Minden osztót el szeretnénk tárolni.  
   - A tömb mérete az aktuális szám (`i`) lesz, mert legrosszabb esetben minden 1-től `i/2` osztó lehet.

2. **Fő logika:**  
   - Végigmegyünk `1`-től `N/2`-ig, mert egy számnak **nincs olyan osztója**, ami nagyobb a felénél (kivéve magát, de azt nem számoljuk).  
   - Ha `N % o == 0`, az `o` osztó, eltároljuk a tömbben.

> **C++ párhuzam:**  
> - Ugyanígy `for` ciklussal lehet keresni az osztókat.  
> - A tömb kezelés C++-ban `std::vector<int>`-tel rugalmasabb.

### Kód
```csharp
using System;

namespace fa3_TokeletesSzam
{
    internal class Program
    {
        // innentől új kód

        static void OsztokKeresese(int[] osztok, int N)
        {
            osztok[0] = 0; // kezdőérték, biztonságosan
            int index = 0; // aktuális tömbhely
            for (int o = 1; o <= N / 2; o++) // csak 1..N/2
            {
                if (N % o == 0) // ha osztó
                {
                    osztok[index] = o; // eltároljuk
                    index++;
                }
            }
        }

        static void Main(string[] args)
        {
            Console.WriteLine("Tökéletes számok program");
            Console.ReadLine();
        }
    }
}
```

---

## 3. fejezet – Osztók összege

### Magyarázat
Most létrehozunk egy függvényt, ami **összeadja az osztókat**.  
- `int OsztokOsszege(int[] osztok)`  
- Itt használjuk a C# **LINQ `.Sum()`** metódusát a gyors összegzéshez.  
- Ez helyettesíti a kézi ciklust: `int osszeg = 0; for(int i=0;i<osztok.Length;i++) osszeg+=osztok[i];`

> **C++ párhuzam:**  
> - C++-ban nincs `.Sum()`, itt `std::accumulate(osztok.begin(), osztok.end(), 0)` lenne az analóg.  

### Kód
```csharp
using System;
using System.Linq;

namespace fa3_TokeletesSzam
{
    internal class Program
    {
        static void OsztokKeresese(int[] osztok, int N)
        {
            osztok[0] = 0;
            int index = 0;
            for (int o = 1; o <= N / 2; o++)
            {
                if (N % o == 0)
                {
                    osztok[index] = o;
                    index++;
                }
            }
        }

        // innentől új kód
        static int OsztokOsszege(int[] osztok)
        {
            return osztok.Sum(); // összeadja az összes osztót
        }

        static void Main(string[] args)
        {
            Console.WriteLine("Tökéletes számok program");
            Console.ReadLine();
        }
    }
}
```

---

## 4. fejezet – Felhasználói input

### Magyarázat
Most kérünk a felhasználótól egy **N értéket**, amiig a program keresni fogja a tökéletes számokat.  
- `do-while` ciklus biztosítja, hogy **N legalább 2 legyen**, mert a 1 nem lehet tökéletes szám.  
- `int.Parse(Console.ReadLine())` konvertálja a stringet számmá.

> **C++ párhuzam:**  
> - `std::cin >> N;` használható, de a hibakezelés kicsit nehezebb lehet.  

### Kód
```csharp
using System;
using System.Linq;

namespace fa3_TokeletesSzam
{
    internal class Program
    {
        static void OsztokKeresese(int[] osztok, int N)
        {
            osztok[0] = 0;
            int index = 0;
            for (int o = 1; o <= N / 2; o++)
            {
                if (N % o == 0)
                {
                    osztok[index] = o;
                    index++;
                }
            }
        }

        static int OsztokOsszege(int[] osztok)
        {
            return osztok.Sum();
        }

        static void Main(string[] args)
        {
            // innentől új kód
            int N;
            do
            {
                Console.Write("N = "); // felhasználó kérdezése
                N = int.Parse(Console.ReadLine()); // input konvertálása int-re
            } while (N < 2); // minimum érték ellenőrzése
        }
    }
}
```

---

## 5. fejezet – Tökéletes számok keresése

### Magyarázat
Most végigmegyünk 1-től N-ig, minden számra:  
1. Létrehozunk egy tömböt az osztók tárolására.  
2. Meghívjuk `OsztokKeresese` függvényt.  
3. Meghívjuk `OsztokOsszege` függvényt, hogy összegyűjtsük az osztókat.  
4. Ha a szám megegyezik az osztók összegével, kiírjuk — ez a tökéletes szám.

> **C++ párhuzam:**  
> - C++-ban ugyanígy végig lehet menni 1..N ciklussal, tömböt vagy vektort használva az osztókhoz.  
> - LINQ-t itt nem tudnánk használni, helyette `std::accumulate`.

### Kód
```csharp
using System;
using System.Linq;

namespace fa3_TokeletesSzam
{
    internal class Program
    {
        static void OsztokKeresese(int[] osztok, int N)
        {
            osztok[0] = 0;
            int index = 0;
            for (int o = 1; o <= N / 2; o++)
            {
                if (N % o == 0)
                {
                    osztok[index] = o;
                    index++;
                }
            }
        }

        static int OsztokOsszege(int[] osztok)
        {
            return osztok.Sum();
        }

        static void Main(string[] args)
        {
            int N;
            do
            {
                Console.Write("N = ");
                N = int.Parse(Console.ReadLine());
            } while (N < 2);

            // innentől új kód
            Console.Write($"{N}-ig a tökéletes számok: ");

            for (int i = 1; i <= N; i++) // végig 1..N
            {
                int[] osztok = new int[i]; // tömb az osztóknak
                OsztokKeresese(osztok, i); // osztók keresése
                int oo = OsztokOsszege(osztok); // osztók összege
                if (i == oo) // ha tökéletes szám
                    Console.Write(i + " "); // kiírás
            }

            Console.WriteLine();
            Console.ReadLine();
        }
    }
}
```

---

# Összegzés

Ebben a programban megtanultuk:
- hogyan lehet **osztókat keresni egy számhoz**,  
- hogyan lehet **tömbben tárolni az osztókat**,  
- hogyan lehet **összeadni az osztókat LINQ `.Sum()`-al**,  
- hogyan lehet **ellenőrizni, hogy egy szám tökéletes-e**,  
- a `do-while` ciklus és felhasználói input kezelésének alapjait.

Ezek a lépések **alapvető programozási fogások**, amelyeket sok további matematikai és logikai feladatban lehet használni.
